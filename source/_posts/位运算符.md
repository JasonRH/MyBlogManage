---
title: 位运算
categories: 其它
tags:
  - 位运算
abbrlink: 60366
date: 2019-02-17 11:14:30
---



下面的a和b都是整数类型，则：

| **含义** | [Pascal语言](https://baike.baidu.com/item/Pascal%E8%AF%AD%E8%A8%80) | C语言        | C#语言       | Java       |
| ------ | ----------------------------------------------------------------- | ---------- |:---------- | ---------- |
| 按位与    | a and b                                                           | a & b      | a & b      | a & b      |
| 按位或    | a or b                                                            | a &#124; b | a &#124; b | a &#124; b |
| 按位异或   | a xor b                                                           | a ^ b      | a ^ b      | a ^ b      |
| 按位取反   | not a                                                             | ~a         | ~a         | ~a         |
| 左移     | a shl b                                                           | a << b     | a << b     | a << b     |
| 带符号右移  | a shr b                                                           | a >> b     | a >> b     | a >> b     |
| 无符号右移  |                                                                   |            |            | a>>> b     |



## 运算说明

=== 1. and运算 & ===

and运算通常用于二进制的取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数。

相同位的两个数字都为1，则为1；若有一个不为1，则为0。

00101

11100

（&；或者and）

---

00100



=== 2. or运算 | ===

or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。

相同位只要一个为1即为1。

00101

11100

（|或者or）

---

11101



=== 3. xor运算 ^ ===

异或的符号是^。按位异或运算, 对等长二进制模式按位或二进制数的每一位执行逻辑按位异或操作. 操作的结果是如果某位不同则该位为1, 否则该位为0.

xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即（a xor b) xor b = a。xor运算可以用于简单的加密，比如我想对我MM说1314520，但怕别人知道，于是双方约定拿我的生日19880516作为[密钥](https://baike.baidu.com/item/%E5%AF%86%E9%92%A5)。1314520 xor 19880516 = 20665500，我就把20665500告诉MM。MM再次计算20665500 xor 19880516的值，得到1314520。

相同位不同则为1，相同则为0。

00101

11100

（^或者xor）

---

11001

运算结果

x <- x # y

y <- x @ y

x <- x @ y

执行了第一句后x变成了x # y。那么第二句实质就是y <- x # y @ y，由于#和@互为逆运算，那么此时的y变成了原来的x。第三句中x实际上被赋值为（x # y) @ x，如果#运算具有交换律，那么赋值后x就变成最初的y了。这三句话的结果是，x和y的位置互换了。

加法和减法互为逆运算，并且加法满足交换律。把#换成+，把@换成-，我们可以写出一个不需要临时变量的swap过程（Pascal）。

procedure swap(var a,b:longint);

begin

a:=a + b;

b:=a - b;

a:=a - b;

end;

好了，刚才不是说xor的逆运算是它本身吗？于是我们就有了一个看起来非常诡异的swap过程：

procedure swap(var a,b:longint);

begin

a:=a xor b;

b:=a xor b;

a:=a xor b;

end;

注意：位运算版本的交换两数不适用于一个数的自我交换。也就是说，如果上述程序的“b”改成“a”的话，其结果是变量a变成零。因此，在使用快速排序时，由于涉及到一个数的自我交换，因此如果要在其中使用位运算版的交换两数的话，应该先判断。具体的时间损耗在此略过。



=== 4. not运算 ~ ===

not运算的定义是把内存中的0和1全部取反。使用not运算时要格外小心，你需要注意整数类型有没有符号。如果not的对象是[无符号整数](https://baike.baidu.com/item/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0)（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用00到$FFFF依次表示的。下面的两个程序（仅语言不同）均返回65435。

var

a:word;

begin

a:=100;

a:=not a;

writeln(a);

end.

```c
#include<stdio.h>
int main()
{
    unsigned short a=100;
    a=~a;
    printf("%d\n",a);
    return 0;
}

```

如果not的对象是有符号的整数，情况就不一样了，稍后我们会在“整数类型的储存”小节中提到。



=== 5. shl运算 << ===

a shl b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 shl 2 = 400。可以看出，a shl b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。

通常认为a shl 1比a * 2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作请尽量用左移一位来代替。

定义一些常量可能会用到shl运算。你可以方便地用1 shl 16 - 1来表示65535。很多算法和数据结构要求数据规模必须是2的幂，此时可以用shl来定义Max_N等常量。

=== 6. shr运算 >> ===

和shl相似，a shr b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。我们也经常用shr 1来代替div 2，比如[二分查找](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)、堆的插入操作等等。想办法用shr代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2操作来代替慢得出奇的mod运算，效率可以提高60%。



## 优先级

C语言中位运算符之间，按优先级顺序排列为

| 1   | ~                     |
| --- | --------------------- |
| 2   | <<、>>                 |
| 3   | &                     |
| 4   | ^                     |
| 5   | &#124;                |
| 6   | &=、^=、&#124;=、<<=、>>= |

## 右移运算(>>)

右移运算符是将一个二进制数按指定移动的位数向右移动。

移动过程中，正数最高位补0，负数最高位补1，无符号数最高位补0。

**补码**

在计算机系统中，数值一律用补码来表示和存储，其中最高位表示符号位，1表示负数，0表示正数。

· 正数的补码是原码自身。

· 负数补码是通过原码计算得到，计算过程为：符号位不变，其余位按照原码取反加1

**补码计算示例**

以计算十进制-100的补码为例，计算过程为：

-100的原码：                   10000000 00000000 00000000 01100100   
符号位保持不变，取反：11111111 11111111 11111111 10011011   
加1后，-100补码为：     11111111 11111111 11111111 10011100

下面右移都是以整数为例，不考虑小数情况。

**正数右移**

正数右移高位需补0，以100右移4位为例：

| **操作** | **二进制**                             | **对应十进制** |
| ------ | ----------------------------------- | --------- |
| 补码     | 00000000 00000000 00000000 01100100 | 100       |
| 右移4位   | 00000000 00000000 00000000 00000110 | 6         |
| 源码     | 00000000 00000000 00000000 00000110 | 6         |

最后可得: 100 >> 4 = 6

正数的右移相当于除法，右移几位就除以2的几次方，如100>>4 等效 100/2^4

**负数右移**

负数右移高位需补1，以-100右移4位为例：

| **操作**     | **二进制**                             | **对应十进制** |
| ---------- | ----------------------------------- | --------- |
| 原码         | 10000000 00000000 00000000 01100100 | -100      |
| 转换为补码      | 11111111 11111111 11111111 10011100 | -100      |
| 右移4位，高位补1  | 11111111 11111111 11111111 11111001 |           |
| 保留符号位，按位取反 | 10000000 00000000 00000000 00000110 |           |
| 加1后转为源码    | 10000000 00000000 00000000 00000111 | -7        |

最后可得： -100 >> 4 = -7

负数的右移不等于除法，即负数右移不能按除以2的n次方计算（n表示移动位数）。

**无符号右移**

无符号右移和正数右移相同，都是高位补0，以-100右移4位为例：

| **操作**    | **二进制**                             | **对应十进制** |
| --------- | ----------------------------------- | --------- |
| 原码        | 10000000 00000000 00000000 01100100 | -100      |
| 转换为补码     | 11111111 11111111 11111111 10011100 | -100      |
| 右移4位，高位补0 | 00001111 11111111 11111111 11111001 |           |
| 转为原码      | 00001111 11111111 11111111 11111001 | 268435449 |

最后可得： -100 >>> 4 = 268435449

右移28位后，最高位为0表示正数，所以原码即为补码本身。   
“>>>”是Java里的无符号右移操作符。

总结

正数的右移，负数的无符号右移，就是相应的补码移位所得，在高位补0即可。   
负数的右移，就是补码高位补1,然后按位取反加1即可。

## 左移运算(<<)

运算规则：

按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。

语法格式：

需要移位的数字 << 移位的次数

例如： 3 << 2，则是将数字3左移2位

计算过程：

3 << 2 首先把3转换为二进制数字0000 0011，然后把该数字高位(左侧)的两个零移出，其他的数字都朝左平移2位，最后在低位(右侧)的两个空位补零。则得到的最终结果是0000 1100，则转换为十进制是12。

数学意义：

在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。
